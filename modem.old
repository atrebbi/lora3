
// ----------------------------------------------------------------------
// Lora BBS Professional Edition - Version 0.16
// Copyright (c) 1995 by Marco Maccaferri. All rights reserved.
//
// History:
//    05/20/95 - Initial coding.
// ----------------------------------------------------------------------

#include "_ldefs.h"
#include "combase.h"
#include "mailer.h"
#include "nodes.h"
#include "menu.h"
#include "schedule.h"
#include "version.h"

#if defined(__DOS__) || defined(__OS2__)
class TLocal : public TBbs
{
public:
   TLocal (USHORT usChannel);
   ~TLocal (void);

   VOID   ReleaseTimeSlice (VOID);
   VOID   Run (VOID);

private:
   USHORT Channel;
   ULONG  Time;
   WINDOW whStatus;
   struct tm *tp;
};

TLocal::TLocal (USHORT usChannel) : TBbs ()
{
   Log = NULL;
   whStatus = 0;
   Channel = usChannel;
}

TLocal::~TLocal (void)
{
   if (Cfg != NULL)
      delete Cfg;
}

VOID TLocal::ReleaseTimeSlice (VOID)
{
   if (whStatus != 0) {
      if (time (NULL) != Time) {
         Time = time (NULL);
         tp = localtime ((time_t *)&Time);
         printsf (24, 71, WHITE|_BLUE, "%02d:%02d:%02d", tp->tm_hour % 24, tp->tm_min % 60, tp->tm_sec % 60);
      }
   }
}

VOID TLocal::Run (VOID)
{
   CHAR Temp[64];
   ULONG CallLen;
   class TScreen *Screen;

   Time = 0L;

   if (Cfg == NULL) {
      if ((Cfg = new TConfig (".\\")) != NULL)
         Cfg->Read (Channel);
   }

   if (Log == NULL) {
      if ((Log = new TLog) != NULL) {
         sprintf (Temp, "%sCH%d.LOG", Cfg->LogPath, Cfg->Channel);
         if (Log->Open (Temp) == TRUE) {
            Log->Display = FALSE;
            Log->Level = Cfg->LogLevel;
            Log->Write (Log->Begin, VERSION, Cfg->Channel);
         }
      }
   }

   if ((Status = new TStatus (Cfg->SystemPath)) != NULL) {
      Status->Activate (Cfg->Channel);
      strcpy (Status->User, "Answering call...");
      Status->Speed = 0L;
      Status->Update ();
   }

   Log->Write ("+Connect Local");

   if ((Screen = new TScreen) != NULL) {
      if ((whStatus = wopen (24, 0, 24, 79, 5, LGREY|_BLUE, LGREY|_BLUE)) != 0) {
         wprintc (0, 34, WHITE|_BLUE, '³');
         wprintc (0, 63, WHITE|_BLUE, '³');
         wprintc (0, 69, WHITE|_BLUE, '³');
      }

      if (Screen->Initialize () == TRUE) {
         Com = Screen;
         showcur ();

         Hangup = FALSE;
         Ansi = TRUE;
         Lang = new TLanguage;
         User = new TUser (Cfg->UserFile);
         Limits = new TLimits (Cfg->SystemPath);

         LastActivity = StartCall = time (NULL);
         CarrierSpeed = 57600L;

         DisplayBanner ();
         ReadFile ((Cfg->Logo[0] == '\0') ? "LOGO" : Cfg->Logo);

         do {
            Printf (Lang->EnterName);
            GetString (Temp, 35, INP_FIELD|INP_FANCY);
            if (whStatus != 0)
               printsf (24, 1, WHITE|_BLUE, "%.32s", Temp);
         } while (AbortSession () == FALSE && LoginUser (Temp) == FALSE);

         if (AbortSession () == FALSE) {
            if (VerifyAccount () == TRUE) {
               class TMenu *Menu = new TMenu (this);

               if (Menu != NULL) {
                  Menu->Run ((Cfg->FirstMenu[0] == '\0') ? "TOP" : Cfg->FirstMenu);
                  delete Menu;
               }
            }

            CallLen = (time (NULL) - StartCall) / 60L;

            User->LastCall = time (NULL);
            User->TodayTime += CallLen;
            User->WeekTime += CallLen;
            User->MonthTime += CallLen;
            User->YearTime += CallLen;
            if (User->Update () == FALSE)
               Log->Write ("!Unable to update user");

            Log->Write (Log->UserOffline, User->Name, User->TotalCalls, CallLen);
         }

         delete Limits;
         Limits = NULL;
         delete User;
         User = NULL;
         delete Lang;
         Lang = NULL;

         Pause (200);
      }

      delete Screen;

      if (whStatus != 0) {
         wactiv (whStatus);
         wclose ();
         whStatus = 0;
      }
   }

   if (Status != NULL) {
      Status->Deactivate ();
      delete Status;
   }

   if (Log != NULL) {
      Log->Write (Log->End);
      delete Log;
   }
}
#endif

// ----------------------------------------------------------------------

class TModem : public TBbs
{
public:
   TModem (USHORT usChannel);
   ~TModem (void);

   LONG   CheckResponse (VOID);
   VOID   ReleaseTimeSlice (VOID);
   VOID   Run (VOID);
   VOID   SendCommand (PSZ pszCmd);

private:
   USHORT Channel, Position;
   CHAR   Response[128];
   ULONG  Time;
   WINDOW whStatus;
#if defined(__OS2__)
   HEV    hEvent;
#endif
   struct tm *tp;
   class  TSerial *Serial;
};

#define AT_NO_RESPONSE   0L
#define AT_BUSY         -1L
#define AT_ERROR        -2L
#define AT_NO_ANSWER    -3L
#define AT_NO_CARRIER   -4L
#define AT_NO_DIALTONE  -5L
#define AT_OK           -6L
#define AT_RING         -7L
#define AT_RINGING      -8L
#define AT_VOICE        -9L

#define AT_FHNG         -10
#define AT_FCON         -11
#define AT_FPOLL        -12
#define AT_FVO          -13
#define AT_FDIS         -14
#define AT_FNSF         -15
#define AT_FCSI         -16
#define AT_FPTS         -17
#define AT_FDCS         -18
#define AT_FNSS         -19
#define AT_FTSI         -20
#define AT_FET          -21

TModem::TModem (USHORT usChannel) : TBbs ()
{
   Log = NULL;
   Serial = NULL;
   whStatus = 0;
   Position = 0;
   Channel = usChannel;
}

TModem::~TModem (void)
{
   if (Cfg != NULL)
      delete Cfg;
}

LONG TModem::CheckResponse (VOID)
{
   USHORT doCheck = FALSE;
   CHAR c, *p;
   LONG RetVal = AT_NO_RESPONSE;

   while (doCheck == FALSE && Com->BytesReady () == TRUE) {
      c = (CHAR)Com->ReadByte ();
      if (Snoop != NULL)
         Snoop->SendByte (c);

      if (c == '\r') {
         Response[Position] = '\0';
         doCheck = TRUE;
         Position = 0;
      }
      else if (c != '\n' && Position < sizeof (Response)) {
         Response[Position++] = c;
         if (Position == sizeof (Response))
            Response[Position - 1] = '\0';
      }
   }

   if (doCheck == TRUE) {
      if (Response[0] == '+' && Response[1] == 'F') {
         if (!strncmp (Response, "+FHS:", 5))
            RetVal = AT_FHNG;
         if (!strncmp (Response, "+FCO:", 5))
            RetVal = AT_FCON;
         if (!strncmp (Response, "+FPO", 4))
            RetVal = AT_FPOLL;
         if (!strncmp (Response, "+FVO", 4))
            RetVal = AT_FVO;
         if (!strncmp (Response, "+FIS:", 5))
            RetVal = AT_FDIS;
         if (!strncmp (Response, "+FNF:", 5))
            RetVal = AT_FNSF;
         if (!strncmp (Response, "+FCI:", 5))
            RetVal = AT_FCSI;
         if (!strncmp (Response, "+FPS:", 5))
            RetVal = AT_FPTS;
         if (!strncmp (Response, "+FCS:", 5))
            RetVal = AT_FDCS;
         if (!strncmp (Response, "+FNS:", 5))
            RetVal = AT_FNSS;
         if (!strncmp (Response, "+FTI:", 5))
            RetVal = AT_FTSI;
         if (!strncmp (Response, "+FET:", 5))
            RetVal = AT_FET;
      }
      else {
         if (!stricmp (Response, "OK"))
            RetVal = AT_OK;
         if (!stricmp (Response, "BUSY"))
            RetVal = AT_BUSY;
         if (!stricmp (Response, "ERROR"))
            RetVal = AT_ERROR;
         if (!stricmp (Response, "NO ANSWER"))
            RetVal = AT_NO_ANSWER;
         if (!stricmp (Response, "NO CARRIER"))
            RetVal = AT_NO_CARRIER;
         if (!stricmp (Response, "NO DIALTONE"))
            RetVal = AT_NO_DIALTONE;
         if (!stricmp (Response, "RING"))
            RetVal = AT_RING;
         if (!stricmp (Response, "RINGING"))
            RetVal = AT_RINGING;
         if (!stricmp (Response, "VOICE"))
            RetVal = AT_VOICE;
         if (!stricmp (Response, "CONNECT FAX"))
            RetVal = AT_FCON;

         if (!strnicmp (Response, "CONNECT", 7) || !strnicmp (Response, "CARRIER", 7)) {
            if (Response[7] == ' ')
               RetVal = atol (&Response[8]);
            else
               RetVal = 300L;
         }
      }
   }

   if (Log != NULL && RetVal != AT_NO_RESPONSE && RetVal != AT_OK) {
      strlwr (Response);
      Response[0] = (CHAR)toupper (Response[0]);
      p = Response;
      while ((p = strchr (p, '/')) != NULL) {
         p++;
         *p = (CHAR)toupper (*p);
      }
      p = Response;
      while ((p = strchr (p, ' ')) != NULL) {
         p++;
         *p = (CHAR)toupper (*p);
      }
      Log->Write (Log->ModemResponse, Response);
   }

   return (RetVal);
}

#define STAT_INITIALIZE    1
#define STAT_INITWAITOK    2
#define STAT_WAITFORCALL   3
#define STAT_ANSWERING     4

VOID TModem::Run (VOID)
{
#if defined(__DOS__)
   USHORT Port;
#endif
   USHORT InitStr, State;
   CHAR Temp[64];
   ULONG CallLen;
   LONG Response, TimeOut;
   class TScreen *Screen;

   Time = 0L;

   if (Cfg == NULL) {
      if ((Cfg = new TConfig (".\\")) != NULL)
         Cfg->Read (Channel);
   }

   if (Log == NULL) {
      if ((Log = new TLog) != NULL) {
         sprintf (Temp, "%sCH%d.LOG", Cfg->LogPath, Cfg->Channel);
         if (Log->Open (Temp) == TRUE) {
            Log->Display = FALSE;
            Log->Level = Cfg->LogLevel;
            Log->Write (Log->Begin, VERSION, Cfg->Channel);
         }
      }
   }

   if ((Screen = new TScreen) != NULL) {
      if ((whStatus = wopen (24, 0, 24, 79, 5, LGREY|_BLUE, LGREY|_BLUE)) != 0) {
         sprintf (Temp, " %-8s ³ %6lu ³ RI CD OH RD SD TR MR RS CS ³", Cfg->Device, Cfg->Speed);
         wprints (0, 0, WHITE|_BLUE, Temp);
      }

      if (Screen->Initialize () == TRUE) {
         Snoop = Screen;
         showcur ();

         if ((Serial = new TSerial) != NULL) {
#if defined(__OS2__) || defined(__NT__)
            if (Serial->Initialize (Cfg->Device, Cfg->Speed, 8, 0, 0) == TRUE) {
#else
            if (!strnicmp (Cfg->Device, "COM", 3))
               Port = (USHORT)atoi (&Cfg->Device[3]);
            else
               Port = (USHORT)atoi (Cfg->Device);

            if (Serial->Initialize (Port, Cfg->Speed, 8, 'N', 1) == TRUE) {
#endif
               Serial->SetDTR (TRUE);
               Com = Serial;

#if defined(__OS2__) || defined(__NT__)
               if ((Screen = new TScreen) != NULL) {
                  if (Screen->Initialize () == TRUE)
                     Snoop = Screen;
               }
#endif

#if defined(__OS2__)
               DosCreateEventSem (NULL, &hEvent, 0L, FALSE);
#endif

               EndRun = FALSE;
               State = STAT_INITIALIZE;

               while (EndRun == FALSE) {
                  switch (State) {
                     case STAT_INITIALIZE:
                        InitStr = 0;
                        while (InitStr < 3 && Cfg->Initialize[InitStr][0] == '\0')
                           InitStr++;

                        if (InitStr < 3) {
                           SendCommand (Cfg->Initialize[InitStr]);
                           TimeOut = TimerSet (1500);
                           State = STAT_INITWAITOK;
                        }
                        else
                           State = STAT_WAITFORCALL;
                        break;

                     case STAT_INITWAITOK:
                        if ((Response = CheckResponse ()) == AT_OK) {
                           InitStr++;
                           while (InitStr < 3 && Cfg->Initialize[InitStr][0] == '\0')
                              InitStr++;
                           if (InitStr < 3)
                              SendCommand (Cfg->Initialize[InitStr]);
                           else
                              State = STAT_WAITFORCALL;
                        }
                        else if (TimeUp (TimeOut)) {
                           if (Log != NULL)
                              Log->Write ("!Modem doesn't report OK");
                           SendCommand (Cfg->Initialize[InitStr]);
                        }
                        break;

                     case STAT_WAITFORCALL:
                        if ((Response = CheckResponse ()) == AT_RING) {
                           SendCommand (Cfg->Answer);
                           Com->ClearInbound ();
                           TimeOut = TimerSet (4500);
                           State = STAT_ANSWERING;
                        }
                        break;

                     case STAT_ANSWERING:
                        if (TimeUp (TimeOut))
                           State = STAT_INITIALIZE;

                        if ((Response = CheckResponse ()) > 0L) {
                           Hangup = FALSE;
                           Ansi = TRUE;
                           Lang = new TLanguage;
                           User = new TUser (Cfg->UserFile);
                           Limits = new TLimits (Cfg->SystemPath);

                           LastActivity = StartCall = time (NULL);
                           CarrierSpeed = Response;

                           DisplayBanner ();
                           ReadFile ((Cfg->Logo[0] == '\0') ? "LOGO" : Cfg->Logo);

                           do {
                              Printf (Lang->EnterName);
                              GetString (Temp, 35, INP_FIELD|INP_FANCY);
                              if (whStatus != 0)
                                 printsf (24, 1, WHITE|_BLUE, "%.32s", Temp);
                           } while (AbortSession () == FALSE && LoginUser (Temp) == FALSE);

                           if (AbortSession () == FALSE) {
                              if (VerifyAccount () == TRUE) {
                                 class TMenu *Menu = new TMenu (this);

                                 if (Menu != NULL) {
                                    Menu->Run ((Cfg->FirstMenu[0] == '\0') ? "TOP" : Cfg->FirstMenu);
                                    delete Menu;
                                 }
                              }

                              CallLen = (time (NULL) - StartCall) / 60L;

                              User->LastCall = time (NULL);
                              User->TodayTime += CallLen;
                              User->WeekTime += CallLen;
                              User->MonthTime += CallLen;
                              User->YearTime += CallLen;
                              if (User->Update () == FALSE && Log != NULL)
                                 Log->Write ("!Unable to update user");

                              if (Log != NULL)
                                 Log->Write (Log->UserOffline, User->Name, User->TotalCalls, CallLen);
                           }

                           delete Limits;
                           Limits = NULL;
                           delete User;
                           User = NULL;
                           delete Lang;
                           Lang = NULL;

                           Pause (200);
                        }
                        break;
                  }

                  if (whStatus != 0) {
                     wprints (0, 21, BLACK|_BLUE, "RI");
                     wprints (0, 24, (Com->Dcd == TRUE) ? WHITE|_BLUE : BLACK|_BLUE, "CD");
                     wprints (0, 27, BLACK|_BLUE, "OH");
                     wprints (0, 30, (Com->Rxd == TRUE) ? WHITE|_BLUE : BLACK|_BLUE, "RD");
                     wprints (0, 33, (Com->Txd == TRUE) ? WHITE|_BLUE : BLACK|_BLUE, "SD");
                     wprints (0, 36, (Com->Dtr == TRUE) ? WHITE|_BLUE : BLACK|_BLUE, "TR");
                     wprints (0, 39, BLACK|_BLUE, "MR");
                     wprints (0, 42, (Com->Rts == TRUE) ? WHITE|_BLUE : BLACK|_BLUE, "RS");
                     wprints (0, 45, (Com->Cts == TRUE) ? WHITE|_BLUE : BLACK|_BLUE, "CS");
                  }

                  ReleaseTimeSlice ();
               }

#if defined(__OS2__)
               DosCloseEventSem (hEvent);
#endif
               if (Log != NULL)
                  Log->Write (Log->End);
            }

            delete Serial;
         }
      }

      if (whStatus != 0) {
         wactiv (whStatus);
         wclose ();
         whStatus = 0;
      }

      delete Screen;
   }

   if (Log != NULL) {
      Log->Write (Log->End);
      delete Log;
   }
}

VOID TModem::ReleaseTimeSlice (VOID)
{
   if (whStatus != 0) {
      if (time (NULL) != Time) {
         Time = time (NULL);
         tp = localtime ((time_t *)&Time);
         printsf (24, 71, WHITE|_BLUE, "%02d:%02d:%02d", tp->tm_hour % 24, tp->tm_min % 60, tp->tm_sec % 60);
      }
   }

#if defined(__OS2__)
   DosWaitEventSem (hEvent, 10L);
#endif
}

VOID TModem::SendCommand (PSZ pszCmd)
{
   while (*pszCmd) {
      switch (*pszCmd) {
         case '|':
            Serial->SendByte ((char)13);
            if (Snoop != NULL)
               Snoop->SendByte ((char)13);
            Pause (10);
            break;

         case 'v':
            Serial->SetDTR (FALSE);
            Pause (10);
            break;

         case '^':
            Serial->SetDTR (TRUE);
            Pause (10);
            break;

         case '~':
            Pause (50);
            break;

         case '`':
            Pause (10);
            break;

         default:
            Serial->SendByte (*pszCmd);
            if (Snoop != NULL)
               Snoop->SendByte (*pszCmd);
            break;
      }
      pszCmd++;
   }

   Serial->SendByte ((char)13);
   if (Snoop != NULL)
      Snoop->SendByte ((char)13);
   Pause (10);
}

// ----------------------------------------------------------------------

void main (int argc, char *argv[])
{
   USHORT i, Quit, DoLocal, Port, Task;
   PSZ LogFile, CfgPath;
   ULONG Speed;
   class TConfig *Cfg;
   class TModem *Modem;
   class TLocal *Local;

   Quit = DoLocal = FALSE;
   LogFile = NULL;
   CfgPath = "";
   Port = 0;
   Speed = 0L;
   Task = 0xFFFFU;

   for (i = 1; i < argc; i++) {
      if (!stricmp (argv[i], "?") || !stricmp (argv[i], "-?") || !strnicmp (argv[i], "-h", 2)) {
#if defined(__OS2__)
         cprintf ("\r\nLoraBBS Standard Edition for OS/2 - Version %s\r\n", VERSION);
#elif defined(__NT__)
         cprintf ("\r\nLoraBBS Standard Edition for Windows/NT - Version %s\r\n", VERSION);
#else
         cprintf ("\r\nLoraBBS Standard Edition for DOS - Version %s\r\n", VERSION);
#endif
         cprintf ("Copyright (c) 1995 by Marco Maccaferri. All rights reserved.\r\n\r\n");
         cprintf ("Usage:\r\n        BBS [switches] [TERM|IMPORT|EXPORT|PACK]\r\n\r\n");
         cprintf ("Where [switches] are:\r\n\r\n");
         cprintf ("   -c<path>  = Sets the path where to find the configuration files\r\n");
         cprintf ("   -l        = Run in local connection mode\r\n");
         cprintf ("   -n<num>   = Sets the task number\r\n");
         cprintf ("   -p<port>  = Overrides the COM port number\r\n");
         cprintf ("   -r<file>  = Sets the name of the log file\r\n");
         cprintf ("   -s<speed> = Overrides the DTE<>DCE speed\r\n");
         Quit = TRUE;
      }
      else if (!strnicmp (argv[i], "-c", 2))
         CfgPath = &argv[i][2];
      else if (!stricmp (argv[i], "-l")) {
         DoLocal = TRUE;
         if (Task == 0xFFFFU)
            Task = 0;
      }
      else if (!strnicmp (argv[i], "-n", 2))
         Task = (USHORT)atoi (&argv[i][2]);
      else if (!strnicmp (argv[i], "-p", 2))
         Port = (USHORT)atoi (&argv[i][2]);
      else if (!strnicmp (argv[i], "-r", 2))
         LogFile = &argv[i][2];
      else if (!strnicmp (argv[i], "-s", 2))
         Speed = atol (&argv[i][2]);
   }

   if (Task == 0xFFFFU)
      Task = 1;

   if (Quit == FALSE) {
      if ((Cfg = new TConfig (CfgPath)) != NULL) {
         if (Cfg->Read (Task) == TRUE) {
            if (Port != 0)
               sprintf (Cfg->Device, "COM%d", Port);
            if (Speed != 0L)
               Cfg->Speed = Speed;

            if (DoLocal == TRUE) {
               if ((Local = new TLocal (Task)) != NULL) {
                  Local->Cfg = Cfg;
                  Local->Run ();
                  if (Local->Log != NULL)
                     delete Local->Log;
                  delete Local;
               }
            }
            else {
               if ((Modem = new TModem (Task)) != NULL) {
                  Modem->Cfg = Cfg;
                  Modem->Run ();
                  delete Modem;
               }
            }

            wcloseall ();
            cclrscrn (LGREY|_BLACK);
         }
      }
   }
}

